<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExtractCommandHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">calendar</a> &gt; <a href="index.source.html" class="el_package">calendar.commandobject</a> &gt; <span class="el_source">ExtractCommandHelper.java</span></div><h1>ExtractCommandHelper.java</h1><pre class="source lang-java linenums">package calendar.commandobject;

import calendar.model.modelinterfaces.Calendar;
import calendar.model.modelinterfaces.Event;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Helper method class to process the string command and extract the important details.
 *
 */
<span class="nc" id="L18">public class ExtractCommandHelper {</span>


  /**
   * Method to get new property value from command. Parses the edit calendar command
   * to extract the new value for a property being edited.
   *
   * @param command user command in format &quot;edit calendar
   *                --name &amp;lt;name&amp;gt; --property &amp;lt;prop&amp;gt; &amp;lt;value&amp;gt;&quot;
   * @return new property value as a String, or null if command format is incorrect
   */
  public static String getPropertyValueFromEditCalendarCommand(String command) {

<span class="fc" id="L31">    String[] parts = command.split(&quot;--property &quot;);</span>

<span class="pc bpc" id="L33" title="1 of 2 branches missed.">    if (parts.length &gt; 1) {</span>

<span class="fc" id="L35">      String[] propertyValue = parts[1].split(&quot; &quot;);</span>
<span class="fc" id="L36">      return propertyValue[1].trim();</span>
    }

<span class="nc" id="L39">    return null;</span>

  }

  /**
   * Method to get calendar property from command. Extracts the property name
   * that is being edited from the edit calendar command.
   *
   * @param command user command in format &quot;edit calendar
   *                --property &amp;lt;property-name&amp;gt; &amp;lt;value&amp;gt;&quot;
   * @return calendar property name as a String, or null if command format is incorrect
   */
  public static String getPropertyFromEditCalendarCommand(String command) {

<span class="fc" id="L53">    String[] parts = command.split(&quot;--property &quot;);</span>


<span class="pc bpc" id="L56" title="1 of 2 branches missed.">    if (parts.length &gt; 1) {</span>
<span class="fc" id="L57">      String[] property = parts[1].split(&quot; &quot;);</span>
<span class="fc" id="L58">      return property[0].trim();</span>
    }

<span class="nc" id="L61">    return null;</span>
  }

  /**
   * Method to get timezone from command. Extracts the timezone specification
   * from a create calendar command.
   *
   * @param command user command in format &quot;create calendar
   *                --name &amp;lt;name&amp;gt; --timezone &amp;lt;timezone&amp;gt;&quot;
   * @return calendar timezone as a String (e.g., &quot;America/New_York&quot;), or null if not found
   */
  public static String getTimezoneFromCalendarCommand(String command) {

<span class="fc" id="L74">    String[] parts = command.split(&quot;--timezone &quot;);</span>

<span class="pc bpc" id="L76" title="1 of 2 branches missed.">    if (parts.length &gt; 1) {</span>
<span class="fc" id="L77">      return parts[1].trim();</span>
    }


<span class="nc" id="L81">    return null;</span>

  }

  /**
   * Method to get calendar Name from command. Extracts the calendar name
   * from various calendar-related commands.
   *
   * @param command user command containing &quot;--name &amp;lt;calendar-name&amp;gt;&quot;
   * @return calendar name as a String, or null if not found
   */
  public static String getCalendarNameFromCommand(String command) {

<span class="fc" id="L94">    String[] parts = command.split(&quot;--name &quot;);</span>

<span class="pc bpc" id="L96" title="1 of 2 branches missed.">    if (parts.length &gt; 1) {</span>
<span class="fc" id="L97">      return parts[1].split(&quot;--&quot;)[0].trim();</span>
    }

<span class="nc" id="L100">    return null;</span>

  }


  /**
   * Retrieves event subject from the command string. Extracts the event subject/title
   * from a create event command, handling both quoted and unquoted subjects.
   *
   * @param commands user input in format &quot;create event &amp;lt;subject&amp;gt; from/on &amp;lt;date&amp;gt;&quot;
   * @return subject string with quotes removed, or empty string if extraction fails
   */
  public static String getSubjectFromCommand(String commands) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">    String keyword = commands.contains(&quot; from &quot;) ? &quot;from&quot; : &quot;on&quot;;</span>

<span class="fc" id="L115">    String subject = commands.substring(commands.indexOf(&quot;event&quot;) + &quot;event&quot;.length(),</span>
<span class="fc" id="L116">        commands.indexOf(&quot; &quot; + keyword + &quot; &quot;)).trim();</span>

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    if (subject.length() &gt; 1) {</span>
<span class="fc" id="L119">      subject = subject.replace(&quot;\&quot;&quot;, &quot;&quot;);</span>
<span class="fc" id="L120">      return subject;</span>
    }

<span class="nc" id="L123">    return subject;</span>
  }


  /**
   * Retrieves date time from command. Parses a datetime value from the command
   * based on the specified keyword position.
   *
   * @param commands user input containing datetime in ISO format
   * @param keyword  either &quot;from&quot; or &quot;to&quot; to indicate which datetime to extract
   * @return LocalDateTime object parsed from the command string
   */
  public static LocalDateTime getDateTimeFromCommand(String commands, String keyword) {
<span class="fc" id="L136">    String keywordWithSpaces = &quot; &quot; + keyword + &quot; &quot;;</span>
<span class="fc" id="L137">    int startIndex = commands.indexOf(keywordWithSpaces) + keywordWithSpaces.length();</span>
    int endIndex;

<span class="fc bfc" id="L140" title="All 2 branches covered.">    if (keyword.equals(&quot;from&quot;)) {</span>
<span class="fc" id="L141">      endIndex = commands.indexOf(&quot; to &quot;);</span>
    } else {
<span class="fc" id="L143">      endIndex = commands.length();</span>
    }

<span class="fc" id="L146">    String dateString = commands.substring(startIndex, endIndex).trim();</span>
<span class="fc" id="L147">    return LocalDateTime.parse(dateString);</span>
  }


  /**
   * Retrieves date from command. Extracts a date value from commands
   * that specify events on a specific date.
   *
   * @param commands user input containing &quot; on &amp;lt;date&amp;gt;&quot;
   * @return LocalDate object parsed from the command string
   */
  public static LocalDate getDateFromCommand(String commands) {
<span class="fc" id="L159">    int startIndex = commands.indexOf(&quot; on &quot;) + &quot; on &quot;.length();</span>
<span class="fc" id="L160">    String dateString = commands.substring(startIndex).trim();</span>
<span class="fc" id="L161">    return LocalDate.parse(dateString);</span>
  }


  /**
   * Gets subject from an edit event command. Extracts the event subject
   * from edit commands by parsing tokens before the &quot;from&quot; keyword.
   *
   * @param command edit event command string
   * @return subject string with quotes removed
   */
  public static String getSubjectFromCommandToEdit(String command) {
<span class="fc" id="L173">    int fromIndex = command.indexOf(&quot; from &quot;);</span>
<span class="fc" id="L174">    String beforeFrom = command.substring(0, fromIndex);</span>

<span class="fc" id="L176">    String[] tokens = beforeFrom.split(&quot; &quot;);</span>
<span class="fc" id="L177">    StringBuilder subject = new StringBuilder();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">    for (int i = 3; i &lt; tokens.length; i++) {</span>
<span class="fc" id="L179">      subject.append(tokens[i]).append(&quot; &quot;);</span>
    }

<span class="fc" id="L182">    String result = subject.toString().trim();</span>
<span class="fc" id="L183">    return result.replace(&quot;\&quot;&quot;, &quot;&quot;);</span>
  }

  /**
   * Gets date time from command for editing events. Extracts datetime values
   * from edit commands based on keyword position.
   *
   * @param commands edit event command string
   * @param keyword  either &quot;from&quot; or &quot;to&quot; indicating which datetime to extract
   * @return LocalDateTime object parsed from the command
   */
  public static LocalDateTime getDateTimeFromCommandToEdit(String commands, String keyword) {
<span class="fc" id="L195">    int startIndex = commands.indexOf(keyword) + keyword.length();</span>
    int endIndex;

<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (keyword.equals(&quot;from&quot;)) {</span>
<span class="fc" id="L199">      endIndex = commands.indexOf(&quot; to &quot;);</span>
    } else {
<span class="fc" id="L201">      endIndex = commands.indexOf(&quot; with &quot;);</span>
    }

<span class="fc" id="L204">    String dateString = commands.substring(startIndex, endIndex).trim();</span>
<span class="fc" id="L205">    return LocalDateTime.parse(dateString);</span>
  }

  /**
   * Gets property value from the subject. Extracts the new value specified
   * after the &quot;with&quot; keyword in edit commands.
   *
   * @param command edit command containing &quot; with &amp;lt;value&amp;gt;&quot;
   * @return property value string with quotes removed
   */
  public static String getPropertyValue(String command) {
<span class="fc" id="L216">    return command.substring(command.indexOf(&quot; with &quot;) + &quot; with &quot;.length())</span>
<span class="fc" id="L217">        .trim().replace(&quot;\&quot;&quot;, &quot;&quot;);</span>
  }

  /**
   * Gets which type of property it is from command. Extracts the property name
   * being edited from the third token of the command.
   *
   * @param command edit command string
   * @return property name string
   */
  public static String getPropertyFromCommand(String command) {
<span class="fc" id="L228">    String[] tokens = command.split(&quot; &quot;);</span>
<span class="fc" id="L229">    return tokens[2];</span>
  }

  /**
   * Extracts the subject from the command using regex. Handles both quoted
   * and unquoted event subjects in create event commands.
   *
   * @param command create event command string
   * @return extracted subject string
   * @throws IllegalArgumentException if subject cannot be extracted
   */
  public static String extractSubject(String command) {
<span class="fc" id="L241">    Pattern quotedPattern = Pattern.compile(&quot;event\\s+\&quot;([^\&quot;]+)\&quot;&quot;);</span>
<span class="fc" id="L242">    Matcher quotedMatcher = quotedPattern.matcher(command);</span>

<span class="pc bpc" id="L244" title="1 of 2 branches missed.">    if (quotedMatcher.find()) {</span>
<span class="fc" id="L245">      return quotedMatcher.group(1);</span>
    }

<span class="nc" id="L248">    Pattern singleWordPattern = Pattern.compile(&quot;event\\s+(\\S+)\\s+(?:from|on)&quot;);</span>
<span class="nc" id="L249">    Matcher singleWordMatcher = singleWordPattern.matcher(command);</span>

<span class="nc bnc" id="L251" title="All 2 branches missed.">    if (singleWordMatcher.find()) {</span>
<span class="nc" id="L252">      return singleWordMatcher.group(1);</span>
    }

<span class="nc" id="L255">    throw new IllegalArgumentException(&quot;Could not extract subject from command: &quot; + command);</span>
  }

  /**
   * Extracts start date from command. Uses regex to find and parse
   * the start datetime following the &quot;from&quot; keyword.
   *
   * @param command command string containing &quot;from &amp;lt;datetime&amp;gt;&quot;
   * @return LocalDateTime representing the start time
   * @throws IllegalArgumentException if start datetime cannot be extracted
   */
  public static LocalDateTime extractStartDateTime(String command) {
<span class="fc" id="L267">    Pattern pattern = Pattern.compile(&quot;from\\s+(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2})&quot;);</span>
<span class="fc" id="L268">    Matcher matcher = pattern.matcher(command);</span>

<span class="pc bpc" id="L270" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L271">      String dateTimeStr = matcher.group(1);</span>
<span class="fc" id="L272">      return LocalDateTime.parse(dateTimeStr);</span>
    }

<span class="nc" id="L275">    throw new IllegalArgumentException(&quot;Could not extract start datetime from command: &quot; + command);</span>
  }

  /**
   * Extracts end date from command. Uses regex to find and parse
   * the end datetime between &quot;to&quot; and &quot;repeats&quot; keywords.
   *
   * @param command command string containing &quot;to &amp;lt;datetime&amp;gt; repeats&quot;
   * @return LocalDateTime representing the end time
   * @throws IllegalArgumentException if end datetime cannot be extracted
   */
  public static LocalDateTime extractEndDateTime(String command) {
<span class="fc" id="L287">    Pattern pattern = Pattern.compile(&quot;to\\s+(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2})\\s+repeats&quot;);</span>
<span class="fc" id="L288">    Matcher matcher = pattern.matcher(command);</span>

<span class="pc bpc" id="L290" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L291">      String dateTimeStr = matcher.group(1);</span>
<span class="fc" id="L292">      return LocalDateTime.parse(dateTimeStr);</span>
    }

<span class="nc" id="L295">    throw new IllegalArgumentException(&quot;Could not extract end datetime from command: &quot; + command);</span>
  }

  /**
   * Extracts day of the event for all-day events. Parses the date
   * following the &quot;on&quot; keyword for all-day event commands.
   *
   * @param command command string containing &quot;on &amp;lt;date&amp;gt;&quot;
   * @return LocalDate representing the day of the event
   * @throws IllegalArgumentException if date cannot be extracted
   */
  public static LocalDate extractDayOfEvent(String command) {
<span class="fc" id="L307">    Pattern pattern = Pattern.compile(&quot;on\\s+(\\d{4}-\\d{2}-\\d{2})&quot;);</span>
<span class="fc" id="L308">    Matcher matcher = pattern.matcher(command);</span>

<span class="pc bpc" id="L310" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L311">      String dateStr = matcher.group(1);</span>
<span class="fc" id="L312">      return LocalDate.parse(dateStr);</span>
    }

<span class="nc" id="L315">    throw new IllegalArgumentException(&quot;Could not extract day of event from command: &quot; + command);</span>
  }

  /**
   * Extracts days of the week when event repeats. Parses the weekday
   * characters following &quot;repeats&quot; keyword for recurring events.
   *
   * @param command command string containing &quot;repeats &amp;lt;weekdays&amp;gt;&quot;
   * @return List of DayOfWeek enums representing recurring days
   * @throws IllegalArgumentException if weekdays cannot be extracted
   */
  public static List&lt;DayOfWeek&gt; extractDaysOfWeekOfEvent(String command) {
<span class="fc" id="L327">    Pattern pattern = Pattern.compile(&quot;repeats\\s+([MTWRFSU]+)&quot;);</span>
<span class="fc" id="L328">    Matcher matcher = pattern.matcher(command);</span>

<span class="pc bpc" id="L330" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L331">      String weekdaysStr = matcher.group(1);</span>
<span class="fc" id="L332">      return parseWeekdays(weekdaysStr);</span>
    }

<span class="nc" id="L335">    throw new IllegalArgumentException(&quot;Could not extract days of week from command: &quot; + command);</span>
  }

  /**
   * Helper method to parse days of week from string. Converts single-character
   * weekday codes to DayOfWeek enums (M=Monday, T=Tuesday, W=Wednesday,
   * R=Thursday, F=Friday, S=Saturday, U=Sunday).
   *
   * @param weekdaysStr string containing weekday characters (e.g., &quot;MWF&quot;)
   * @return List of corresponding DayOfWeek enums
   * @throws IllegalArgumentException if invalid weekday character is encountered
   */
  public static List&lt;DayOfWeek&gt; parseWeekdays(String weekdaysStr) {
<span class="fc" id="L348">    List&lt;DayOfWeek&gt; days = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L350" title="All 2 branches covered.">    for (char c : weekdaysStr.toCharArray()) {</span>
<span class="pc bpc" id="L351" title="3 of 8 branches missed.">      switch (c) {</span>
        case 'M':
<span class="fc" id="L353">          days.add(DayOfWeek.MONDAY);</span>
<span class="fc" id="L354">          break;</span>
        case 'T':
<span class="fc" id="L356">          days.add(DayOfWeek.TUESDAY);</span>
<span class="fc" id="L357">          break;</span>
        case 'W':
<span class="fc" id="L359">          days.add(DayOfWeek.WEDNESDAY);</span>
<span class="fc" id="L360">          break;</span>
        case 'R':
<span class="fc" id="L362">          days.add(DayOfWeek.THURSDAY);</span>
<span class="fc" id="L363">          break;</span>
        case 'F':
<span class="fc" id="L365">          days.add(DayOfWeek.FRIDAY);</span>
<span class="fc" id="L366">          break;</span>
        case 'S':
<span class="nc" id="L368">          days.add(DayOfWeek.SATURDAY);</span>
<span class="nc" id="L369">          break;</span>
        case 'U':
<span class="nc" id="L371">          days.add(DayOfWeek.SUNDAY);</span>
<span class="nc" id="L372">          break;</span>
        default:
<span class="nc" id="L374">          throw new IllegalArgumentException(&quot;Invalid weekday character: &quot; + c);</span>
      }
    }

<span class="fc" id="L378">    return days;</span>
  }

  /**
   * Extracts number of times the event repeats from command. Parses
   * the repeat count from &quot;for &amp;lt;n&amp;gt; times&quot; pattern in recurring events.
   *
   * @param command command string containing &quot;for &amp;lt;number&amp;gt; times&quot;
   * @return integer representing number of repetitions
   * @throws IllegalArgumentException if repeat times cannot be extracted
   */
  public static int extractRepeatTimes(String command) {
<span class="fc" id="L390">    Pattern pattern = Pattern.compile(&quot;for\\s+(\\d+)\\s+times&quot;);</span>
<span class="fc" id="L391">    Matcher matcher = pattern.matcher(command);</span>

<span class="pc bpc" id="L393" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L394">      String timesStr = matcher.group(1);</span>
<span class="fc" id="L395">      return Integer.parseInt(timesStr);</span>
    }

<span class="nc" id="L398">    throw new IllegalArgumentException(&quot;Could not extract repeat times from command: &quot; + command);</span>
  }

  /**
   * Extracts last day until the event should repeat. Parses the end date
   * for recurring events from &quot;until &amp;lt;date&amp;gt;&quot; pattern.
   *
   * @param command command string containing &quot;until &amp;lt;date&amp;gt;&quot;
   * @return LocalDate representing the last day of recurrence
   * @throws IllegalArgumentException if until date cannot be extracted
   */
  public static LocalDate extractTillLastEventDay(String command) {
<span class="fc" id="L410">    Pattern pattern = Pattern.compile(&quot;until\\s+(\\d{4}-\\d{2}-\\d{2})&quot;);</span>
<span class="fc" id="L411">    Matcher matcher = pattern.matcher(command);</span>

<span class="pc bpc" id="L413" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L414">      String dateStr = matcher.group(1);</span>
<span class="fc" id="L415">      return LocalDate.parse(dateStr);</span>
    }

<span class="nc" id="L418">    throw new IllegalArgumentException(&quot;Could not extract until date from command: &quot; + command);</span>
  }

  /**
   * Helper method to edit a single event. Modifies the specified property
   * of an event with the new value provided.
   *
   * @param event    the Event object to be modified
   * @param property the property name to modify (subject, start,
   *                 end, description, status, Location)
   * @param newValue the new value to set for the property
   */
  public static void editSingleEvent(Event event, String property, String newValue) {
<span class="fc" id="L431">    String message = &quot;new property value cannot be the same as old property value&quot;;</span>
<span class="pc bpc" id="L432" title="5 of 7 branches missed.">    switch (property) {</span>
      case &quot;subject&quot;:
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (event.modifySubject(newValue)==null){</span>
<span class="nc" id="L435">          System.out.println(message);</span>


        } else {
<span class="fc" id="L439">          System.out.println(&quot;Edited Event:&quot; + event.toString());</span>
        }

<span class="fc" id="L442">        break;</span>
      case &quot;start&quot;:
<span class="fc" id="L444">        LocalDateTime dateTime = LocalDateTime.parse(newValue);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if(event.modifyStartDate(dateTime.toLocalDate())==null){</span>
<span class="fc" id="L446">          System.out.println(message);</span>

        }

<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (event.modifyStartTime(dateTime.toLocalTime())==null){</span>
<span class="nc" id="L451">          System.out.println(message);</span>

        }
        else {
<span class="fc" id="L455">          System.out.println(&quot;Edited Event: &quot; + event.toString());</span>
        }
<span class="fc" id="L457">        break;</span>

      case &quot;end&quot;:
<span class="nc" id="L460">        LocalDateTime dateTime2 = LocalDateTime.parse(newValue);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if(event.modifyEndDate(dateTime2.toLocalDate())==null){</span>
<span class="nc" id="L462">          System.out.println(message);</span>

        }
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if(event.modifyEndTime(dateTime2.toLocalTime())==null){</span>
<span class="nc" id="L466">          System.out.println(message);</span>

        }
        else {
<span class="nc" id="L470">          System.out.println(&quot;Edited Event &quot; + event.toString());</span>
        }


<span class="nc" id="L474">        break;</span>

      case &quot;description&quot;:
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (event.modifyDescription(newValue)==null){</span>
<span class="nc" id="L478">          System.out.println(message);</span>

        }
        else {
<span class="nc" id="L482">          System.out.println(&quot;Edited Event &quot; + event.toString());</span>

        }

<span class="nc" id="L486">        break;</span>
      case &quot;status&quot;:
<span class="nc bnc" id="L488" title="All 4 branches missed.">        if (newValue.equalsIgnoreCase(&quot;Public&quot;) || newValue.equalsIgnoreCase(&quot;Private&quot;)) {</span>
<span class="nc" id="L489">          event.modifyStatus(newValue);</span>
<span class="nc" id="L490">          System.out.println(&quot;Edited Event &quot; + event.toString());</span>
        } else {
<span class="nc" id="L492">          System.out.println(&quot;Status can only be either Public or Private&quot;);</span>

        }

<span class="nc" id="L496">        break;</span>

      case &quot;location&quot;:
<span class="nc bnc" id="L499" title="All 4 branches missed.">        if(newValue.equalsIgnoreCase(&quot;Physical&quot;) || newValue.equalsIgnoreCase(&quot;Online&quot;)) {</span>
<span class="nc" id="L500">          event.modifyLocation(newValue);</span>
<span class="nc" id="L501">          System.out.println(&quot;Edited Event &quot; + event.toString());</span>
        } else {
<span class="nc" id="L503">          System.out.println(&quot;Location can only be either Physical, Online&quot;);</span>
        }

<span class="nc" id="L506">        break;</span>

      default:
<span class="nc" id="L509">        System.out.println(&quot;Invalid property&quot;);</span>
    }

<span class="fc" id="L512">  }</span>

  /**
   * Helper method to edit a single event in a series. Modifies the specified property
   * of an event with the new value provided.
   *
   * @param event    the Event object to be modified
   * @param property the property name to modify (subject, start,
   *                 end, description, status, Location)
   * @param newValue the new value to set for the property
   */
  public static void editSingleEventInSeries(Event event, String property, String newValue) {
<span class="nc bnc" id="L524" title="All 7 branches missed.">    switch (property) {</span>
      case &quot;subject&quot;:
<span class="nc" id="L526">        event.modifySubject(newValue);</span>
<span class="nc" id="L527">        System.out.println(&quot;Edited Event:&quot; + event.toString());</span>

<span class="nc" id="L529">        break;</span>
      case &quot;start&quot;:
<span class="nc" id="L531">        LocalDateTime dateTime = LocalDateTime.parse(newValue);</span>
<span class="nc" id="L532">        event.modifyStartTime(dateTime.toLocalTime());</span>

<span class="nc" id="L534">        System.out.println(&quot;Edited Event: &quot; + event.toString());</span>

<span class="nc" id="L536">        break;</span>
      case &quot;end&quot;:
<span class="nc" id="L538">        LocalDateTime dateTime2 = LocalDateTime.parse(newValue);</span>
<span class="nc" id="L539">        event.modifyEndTime(dateTime2.toLocalTime());</span>

<span class="nc" id="L541">        System.out.println(&quot;Edited Event &quot; + event.toString());</span>
<span class="nc" id="L542">        break;</span>

      case &quot;description&quot;:
<span class="nc" id="L545">        event.modifyDescription(newValue);</span>
<span class="nc" id="L546">        System.out.println(&quot;Edited Event &quot; + event.toString());</span>

<span class="nc" id="L548">        break;</span>
      case &quot;status&quot;:
<span class="nc" id="L550">        event.modifyStatus(newValue);</span>
<span class="nc" id="L551">        System.out.println(&quot;Edited Event &quot; + event.toString());</span>

<span class="nc" id="L553">        break;</span>

      case &quot;location&quot;:
<span class="nc" id="L556">        event.modifyLocation(newValue);</span>
<span class="nc" id="L557">        System.out.println(&quot;Edited Event &quot; + event.toString());</span>

<span class="nc" id="L559">        break;</span>

      default:
<span class="nc" id="L562">        System.out.println(&quot;Invalid property&quot;);</span>
    }

<span class="nc" id="L565">  }</span>

  /**
   * Validates if the edit would create a duplicate event. Checks whether
   * modifying an event's property would result in a duplicate event in the calendar.
   *
   * @param originalEvent the event being edited
   * @param property      the property being modified
   * @param newValue      the new value for the property
   * @param calendar      the calendar containing all events
   * @return true if the edit would create a duplicate, false otherwise
   */
  public static boolean wouldCreateDuplicate(Event originalEvent, String property,
                                             String newValue, Calendar calendar) {
<span class="fc" id="L579">    String newSubject = originalEvent.getSubject();</span>
<span class="fc" id="L580">    LocalDate newStartDate = originalEvent.getStartDate();</span>
<span class="fc" id="L581">    LocalDate newEndDate = originalEvent.getEndDate();</span>
<span class="fc" id="L582">    LocalTime newStartTime = originalEvent.getStartTime();</span>
<span class="fc" id="L583">    LocalTime newEndTime = originalEvent.getEndTime();</span>

<span class="pc bpc" id="L585" title="2 of 4 branches missed.">    switch (property) {</span>
      case &quot;subject&quot;:
<span class="fc" id="L587">        newSubject = newValue;</span>
<span class="fc" id="L588">        break;</span>
      case &quot;start&quot;:
<span class="fc" id="L590">        LocalDateTime startDateTime = LocalDateTime.parse(newValue);</span>
<span class="fc" id="L591">        newStartDate = startDateTime.toLocalDate();</span>
<span class="fc" id="L592">        newStartTime = startDateTime.toLocalTime();</span>
<span class="fc" id="L593">        break;</span>
      case &quot;end&quot;:
<span class="nc" id="L595">        LocalDateTime endDateTime = LocalDateTime.parse(newValue);</span>
<span class="nc" id="L596">        newEndDate = endDateTime.toLocalDate();</span>
<span class="nc" id="L597">        newEndTime = endDateTime.toLocalTime();</span>
<span class="nc" id="L598">        break;</span>
      default:
<span class="nc" id="L600">        System.out.println(&quot;Unknown property: &quot; + property);</span>
        break;
    }

<span class="fc bfc" id="L604" title="All 2 branches covered.">    for (Event existingEvent : calendar.getCalendarStore().values()) {</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">      if (existingEvent != originalEvent</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">          &amp;&amp; existingEvent.getSubject().equals(newSubject)</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">          &amp;&amp; existingEvent.getStartDate().equals(newStartDate)</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">          &amp;&amp; existingEvent.getEndDate().equals(newEndDate)</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">          &amp;&amp; existingEvent.getStartTime().equals(newStartTime)</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">          &amp;&amp; existingEvent.getEndTime().equals(newEndTime)) {</span>
<span class="nc" id="L611">        return true;</span>
      }
<span class="fc" id="L613">    }</span>
<span class="fc" id="L614">    return false;</span>
  }

  /**
   * Retrieves property name from command. Extracts the property to be edited
   * from edit series or edit events commands using regex.
   *
   * @param command edit series/events command string
   * @return property name (subject, start, end, description, location, or status)
   * @throws IllegalArgumentException if property cannot be extracted or is invalid
   */
  public static String extractProperty(String command) {
<span class="fc" id="L626">    Pattern pattern = null;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">    if (command.contains(&quot;series&quot;)) {</span>
<span class="fc" id="L628">      pattern = Pattern.compile(&quot;edit\\s+series\\s+(\\w+)\\s+&quot;);</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">    } else if (command.contains(&quot;events&quot;)) {</span>
<span class="fc" id="L630">      pattern = Pattern.compile(&quot;edit\\s+events\\s+(\\w+)\\s+&quot;);</span>
    }

<span class="pc bpc" id="L633" title="1 of 2 branches missed.">    if (pattern == null) {</span>
<span class="nc" id="L634">      throw new IllegalArgumentException(&quot;Could not extract property from command: &quot; + command);</span>
    }

<span class="fc" id="L637">    Matcher matcher = pattern.matcher(command);</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L639">      String property = matcher.group(1).toLowerCase();</span>

<span class="pc bpc" id="L641" title="1 of 4 branches missed.">      if (property.equals(&quot;subject&quot;) || property.equals(&quot;start&quot;)</span>
<span class="nc bnc" id="L642" title="All 4 branches missed.">          || property.equals(&quot;end&quot;) || property.equals(&quot;description&quot;)</span>
<span class="nc bnc" id="L643" title="All 4 branches missed.">          || property.equals(&quot;location&quot;) || property.equals(&quot;status&quot;)) {</span>
<span class="fc" id="L644">        return property;</span>
      } else {
<span class="nc" id="L646">        throw new IllegalArgumentException(&quot;Invalid property: &quot; + property);</span>
      }
    }

<span class="nc" id="L650">    throw new IllegalArgumentException(&quot;Could not extract property from command: &quot; + command);</span>
  }

  /**
   * Retrieves the subject from command. Extracts event subject from
   * edit series/events commands, handling both quoted and unquoted subjects.
   *
   * @param command edit series/events command string
   * @return event subject string
   * @throws IllegalArgumentException if subject cannot be extracted
   */
  public static String extractEventSubject(String command) {
<span class="fc" id="L662">    Pattern propertyPattern = null;</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">    if (command.contains(&quot;series&quot;)) {</span>
<span class="fc" id="L664">      propertyPattern = Pattern.compile(&quot;edit\\s+series\\s+\\w+\\s+&quot;);</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">    } else if (command.contains(&quot;events&quot;)) {</span>
<span class="fc" id="L666">      propertyPattern = Pattern.compile(&quot;edit\\s+events\\s+\\w+\\s+&quot;);</span>
    }

<span class="pc bpc" id="L669" title="1 of 2 branches missed.">    if (propertyPattern == null) {</span>
<span class="nc" id="L670">      throw new IllegalArgumentException(&quot;Could not extract subject from command: &quot; + command);</span>
    }

<span class="fc" id="L673">    Matcher propertyMatcher = propertyPattern.matcher(command);</span>

<span class="pc bpc" id="L675" title="1 of 2 branches missed.">    if (!propertyMatcher.find()) {</span>
<span class="nc" id="L676">      throw new IllegalArgumentException(&quot;Invalid command format: &quot; + command);</span>
    }

<span class="fc" id="L679">    int afterPropertyIndex = propertyMatcher.end();</span>
<span class="fc" id="L680">    String remainingCommand = command.substring(afterPropertyIndex);</span>

<span class="fc" id="L682">    Pattern quotedPattern = Pattern.compile(&quot;^\&quot;([^\&quot;]+)\&quot;\\s+from&quot;);</span>
<span class="fc" id="L683">    Matcher quotedMatcher = quotedPattern.matcher(remainingCommand);</span>

<span class="pc bpc" id="L685" title="1 of 2 branches missed.">    if (quotedMatcher.find()) {</span>
<span class="nc" id="L686">      return quotedMatcher.group(1);</span>
    }

<span class="fc" id="L689">    Pattern singleWordPattern = Pattern.compile(&quot;^(\\S+)\\s+from&quot;);</span>
<span class="fc" id="L690">    Matcher singleWordMatcher = singleWordPattern.matcher(remainingCommand);</span>

<span class="pc bpc" id="L692" title="1 of 2 branches missed.">    if (singleWordMatcher.find()) {</span>
<span class="fc" id="L693">      return singleWordMatcher.group(1);</span>
    }

<span class="nc" id="L696">    throw new IllegalArgumentException(&quot;Could not extract event subject from command: &quot; + command);</span>
  }

  /**
   * Retrieves date time from command. Extracts datetime string
   * following the &quot;from&quot; keyword using regex.
   *
   * @param command command containing &quot;from &amp;lt;datetime&amp;gt;&quot;
   * @return datetime string in ISO format (yyyy-MM-ddTHH:mm)
   * @throws IllegalArgumentException if datetime cannot be extracted
   */
  public static String extractDateTimeString(String command) {
<span class="fc" id="L708">    Pattern pattern = Pattern.compile(&quot;from\\s+(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2})&quot;);</span>
<span class="fc" id="L709">    Matcher matcher = pattern.matcher(command);</span>

<span class="pc bpc" id="L711" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L712">      return matcher.group(1);</span>
    }

<span class="nc" id="L715">    throw new IllegalArgumentException(&quot;Could not extract datetime from command: &quot; + command);</span>
  }

  /**
   * Extracts the new property value. Parses the new value for a property
   * from the &quot;with&quot; clause, handling different property types appropriately.
   *
   * @param command  command containing &quot; with &amp;lt;value&amp;gt;&quot;
   * @param property the property type being edited
   * @return extracted value string appropriate for the property type
   * @throws IllegalArgumentException if value cannot be extracted or is invalid for property type
   */
  public static String extractNewPropertyValue(String command, String property) {
<span class="fc" id="L728">    int withIndex = command.indexOf(&quot; with &quot;);</span>

<span class="pc bpc" id="L730" title="1 of 2 branches missed.">    if (withIndex == -1) {</span>
<span class="nc" id="L731">      throw new IllegalArgumentException(&quot;Could not find 'with' clause in command: &quot; + command);</span>
    }

<span class="fc" id="L734">    String valueStr = command.substring(withIndex + 6).trim();</span>

<span class="pc bpc" id="L736" title="1 of 3 branches missed.">    switch (property) {</span>
      case &quot;start&quot;:
      case &quot;end&quot;:
<span class="fc" id="L739">        Pattern dateTimePattern = Pattern.compile(&quot;^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2})&quot;);</span>
<span class="fc" id="L740">        Matcher dateTimeMatcher = dateTimePattern.matcher(valueStr);</span>
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        if (dateTimeMatcher.find()) {</span>
<span class="fc" id="L742">          return dateTimeMatcher.group(1);</span>
        } else {
<span class="nc" id="L744">          throw new IllegalArgumentException(&quot;Invalid datetime format for &quot;</span>
              + property + &quot;: &quot; + valueStr);
        }

      case &quot;subject&quot;:
      case &quot;description&quot;:
      case &quot;location&quot;:
      case &quot;status&quot;:
<span class="pc bpc" id="L752" title="2 of 4 branches missed.">        if (valueStr.startsWith(&quot;\&quot;&quot;) &amp;&amp; valueStr.endsWith(&quot;\&quot;&quot;)) {</span>
<span class="fc" id="L753">          return valueStr.substring(1, valueStr.length() - 1);</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">        } else if (valueStr.startsWith(&quot;\&quot;&quot;)) {</span>
<span class="nc" id="L755">          int closingQuoteIndex = valueStr.indexOf(&quot;\&quot;&quot;, 1);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">          if (closingQuoteIndex != -1) {</span>
<span class="nc" id="L757">            return valueStr.substring(1, closingQuoteIndex);</span>
          }
        }
<span class="nc" id="L760">        return valueStr.split(&quot;\\s+&quot;)[0];</span>

      default:
<span class="nc" id="L763">        throw new IllegalArgumentException(&quot;Unknown property type: &quot; + property);</span>
    }
  }

  /**
   * Extracts subject from copy event command. Parses the event subject
   * from a copy event command.
   *
   * @param command copy event command string
   * @return event subject string
   * @throws IllegalArgumentException if command format is invalid
   */
  public static String extractSubjectFromCopyEvent(String command) {
<span class="fc" id="L776">    String[] parts = command.split(&quot; on &quot;);</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">    if (parts.length &lt; 2) {</span>
<span class="nc" id="L778">      throw new IllegalArgumentException(&quot;Invalid copy event command format&quot;);</span>
    }
<span class="fc" id="L780">    String eventPart = parts[0].replace(&quot;copy event&quot;, &quot;&quot;).trim();</span>
<span class="fc" id="L781">    return eventPart;</span>
  }

  /**
   * Extracts start datetime from copy event command. Parses the source
   * event's datetime from a copy event command.
   *
   * @param command copy event command containing source datetime
   * @return LocalDateTime of the source event
   * @throws IllegalArgumentException if command format is invalid
   */
  public static LocalDateTime extractStartDateTimeFromCopyEvent(String command) {
<span class="fc" id="L793">    int onIndex = command.indexOf(&quot; on &quot;);</span>
<span class="fc" id="L794">    int targetIndex = command.indexOf(&quot; --target &quot;);</span>
<span class="pc bpc" id="L795" title="2 of 4 branches missed.">    if (onIndex == -1 || targetIndex == -1) {</span>
<span class="nc" id="L796">      throw new IllegalArgumentException(&quot;Invalid copy event command format&quot;);</span>
    }
<span class="fc" id="L798">    String dateTimeStr = command.substring(onIndex + 4, targetIndex).trim();</span>
<span class="fc" id="L799">    return LocalDateTime.parse(dateTimeStr);</span>
  }

  /**
   * Extracts calendar name from copy event command. Parses the target
   * calendar name from a copy event command.
   *
   * @param command copy event command containing &quot;--target &amp;lt;calendar&amp;gt;&quot;
   * @return target calendar name string
   * @throws IllegalArgumentException if command format is invalid
   */
  public static String extractCalendarNameFromCopyEvent(String command) {
<span class="fc" id="L811">    int targetIndex = command.indexOf(&quot; --target &quot;);</span>
<span class="fc" id="L812">    int toIndex = command.lastIndexOf(&quot; to &quot;);</span>
<span class="pc bpc" id="L813" title="2 of 4 branches missed.">    if (targetIndex == -1 || toIndex == -1) {</span>
<span class="nc" id="L814">      throw new IllegalArgumentException(&quot;Invalid copy event command format&quot;);</span>
    }
<span class="fc" id="L816">    String calendarName = command.substring(targetIndex + 10, toIndex).trim();</span>
<span class="fc" id="L817">    return calendarName;</span>
  }

  /**
   * Extracts target datetime from copy event command. Parses the target
   * datetime where the event should be copied to.
   *
   * @param command copy event command containing &quot; to &amp;lt;datetime&amp;gt;&quot;
   * @return LocalDateTime for the copied event
   * @throws IllegalArgumentException if command format is invalid
   */
  public static LocalDateTime extractTargetDateTimeFromCopyEvent(String command) {
<span class="fc" id="L829">    int toIndex = command.lastIndexOf(&quot; to &quot;);</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">    if (toIndex == -1) {</span>
<span class="nc" id="L831">      throw new IllegalArgumentException(&quot;Invalid copy event command format&quot;);</span>
    }
<span class="fc" id="L833">    String targetDateTimeStr = command.substring(toIndex + 4).trim();</span>
<span class="fc" id="L834">    return LocalDateTime.parse(targetDateTimeStr);</span>
  }

  /**
   * Extracts source date for copy events on command. Parses the source
   * date from which events should be copied.
   *
   * @param command copy events command containing &quot; on &amp;lt;date&amp;gt;&quot;
   * @return LocalDate of source events
   * @throws IllegalArgumentException if command format is invalid
   */
  public static LocalDate extractSourceDate(String command) {
<span class="fc" id="L846">    int onIndex = command.indexOf(&quot; on &quot;);</span>
<span class="fc" id="L847">    int targetIndex = command.indexOf(&quot; --target &quot;);</span>
<span class="pc bpc" id="L848" title="2 of 4 branches missed.">    if (onIndex == -1 || targetIndex == -1) {</span>
<span class="nc" id="L849">      throw new IllegalArgumentException(&quot;Invalid copy events command format&quot;);</span>
    }
<span class="fc" id="L851">    String dateStr = command.substring(onIndex + 4, targetIndex).trim();</span>
<span class="fc" id="L852">    return LocalDate.parse(dateStr);</span>
  }

  /**
   * Extracts calendar name from copy events on command. Parses the target
   * calendar name for copying events on a specific date.
   *
   * @param command copy events command containing &quot;--target &amp;lt;calendar&amp;gt;&quot;
   * @return target calendar name string
   * @throws IllegalArgumentException if command format is invalid
   */
  public static String extractCalendarNameFromCopyEventsOn(String command) {
<span class="fc" id="L864">    int targetIndex = command.indexOf(&quot; --target &quot;);</span>
<span class="fc" id="L865">    int toIndex = command.lastIndexOf(&quot; to &quot;);</span>
<span class="pc bpc" id="L866" title="2 of 4 branches missed.">    if (targetIndex == -1 || toIndex == -1) {</span>
<span class="nc" id="L867">      throw new IllegalArgumentException(&quot;Invalid copy events command format&quot;);</span>
    }
<span class="fc" id="L869">    String calendarName = command.substring(targetIndex + 10, toIndex).trim();</span>
<span class="fc" id="L870">    return calendarName;</span>
  }

  /**
   * Extracts target date for copy events on command. Parses the target
   * date where events should be copied to.
   *
   * @param command copy events command containing &quot; to &amp;lt;date&amp;gt;&quot;
   * @return LocalDate for the copied events
   * @throws IllegalArgumentException if command format is invalid
   */
  public static LocalDate extractTargetDateOn(String command) {
<span class="fc" id="L882">    int toIndex = command.lastIndexOf(&quot; to &quot;);</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">    if (toIndex == -1) {</span>
<span class="nc" id="L884">      throw new IllegalArgumentException(&quot;Invalid copy events command format&quot;);</span>
    }
<span class="fc" id="L886">    String targetDateStr = command.substring(toIndex + 4).trim();</span>
<span class="fc" id="L887">    return LocalDate.parse(targetDateStr);</span>
  }

  /**
   * Extracts source start date for copy events between command. Parses
   * the start date of the range from which events should be copied.
   *
   * @param command copy events command containing &quot; between &amp;lt;date&amp;gt;&quot;
   * @return LocalDate marking start of source range
   * @throws IllegalArgumentException if command format is invalid
   */
  public static LocalDate extractSourceStartDate(String command) {
<span class="fc" id="L899">    int betweenIndex = command.indexOf(&quot; between &quot;);</span>
<span class="fc" id="L900">    int andIndex = command.indexOf(&quot; and &quot;);</span>
<span class="pc bpc" id="L901" title="2 of 4 branches missed.">    if (betweenIndex == -1 || andIndex == -1) {</span>
<span class="nc" id="L902">      throw new IllegalArgumentException(&quot;Invalid copy events between command format&quot;);</span>
    }
<span class="fc" id="L904">    String startDateStr = command.substring(betweenIndex + 9, andIndex).trim();</span>
<span class="fc" id="L905">    return LocalDate.parse(startDateStr);</span>
  }

  /**
   * Extracts source end date for copy events between command. Parses
   * the end date of the range from which events should be copied.
   *
   * @param command copy events command containing &quot; and &amp;lt;date&amp;gt;&quot;
   * @return LocalDate marking end of source range
   * @throws IllegalArgumentException if command format is invalid
   */
  public static LocalDate extractSourceEndDate(String command) {
<span class="fc" id="L917">    int andIndex = command.indexOf(&quot; and &quot;);</span>
<span class="fc" id="L918">    int targetIndex = command.indexOf(&quot; --target &quot;);</span>
<span class="pc bpc" id="L919" title="2 of 4 branches missed.">    if (andIndex == -1 || targetIndex == -1) {</span>
<span class="nc" id="L920">      throw new IllegalArgumentException(&quot;Invalid copy events between command format&quot;);</span>
    }
<span class="fc" id="L922">    String endDateStr = command.substring(andIndex + 5, targetIndex).trim();</span>
<span class="fc" id="L923">    return LocalDate.parse(endDateStr);</span>
  }

  /**
   * Extracts calendar name from copy events between command. Parses the
   * target calendar name for copying events in a date range.
   *
   * @param command copy events command containing &quot;--target &amp;lt;calendar&amp;gt;&quot;
   * @return target calendar name string
   * @throws IllegalArgumentException if command format is invalid
   */
  public static String extractCalendarNameFromCopyEventsBetween(String command) {
<span class="fc" id="L935">    int targetIndex = command.indexOf(&quot; --target &quot;);</span>
<span class="fc" id="L936">    int toIndex = command.lastIndexOf(&quot; to &quot;);</span>
<span class="pc bpc" id="L937" title="2 of 4 branches missed.">    if (targetIndex == -1 || toIndex == -1) {</span>
<span class="nc" id="L938">      throw new IllegalArgumentException(&quot;Invalid copy events between command format&quot;);</span>
    }
<span class="fc" id="L940">    String calendarName = command.substring(targetIndex + 10, toIndex).trim();</span>
<span class="fc" id="L941">    return calendarName;</span>
  }

  /**
   * Extracts target date for copy events between command. Parses the
   * target date where events from a date range should be copied to.
   *
   * @param command copy events command containing &quot; to &amp;lt;date&amp;gt;&quot;
   * @return LocalDate for the copied events
   * @throws IllegalArgumentException if command format is invalid
   */
  public static LocalDate extractTargetDateBetween(String command) {
<span class="fc" id="L953">    int toIndex = command.lastIndexOf(&quot; to &quot;);</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">    if (toIndex == -1) {</span>
<span class="nc" id="L955">      throw new IllegalArgumentException(&quot;Invalid copy events between command format&quot;);</span>
    }
<span class="fc" id="L957">    String targetDateStr = command.substring(toIndex + 4).trim();</span>
<span class="fc" id="L958">    return LocalDate.parse(targetDateStr);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>